# 查找基础

## +基础1

**在有序表中二分查找值为 key 的元素**

```c
int binsearch(SqList L, int key) {
    int low = 0, high = L.length - 1, mid;
    while (low <= high) {
        mid = (low + high) / 2;
        if (L.data[mid] == key)
            return mid + 1;
        else if (L.data[mid] < key)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
} // 非递归，时空复杂度分别为 O(logN) 和 O(1)
```

```c
int func(SqList L, int key, int low, int high) {
    if (low > high)
        return -1;
    int mid = (low + high) / 2;
    if (L.data[mid] == key)
        return mid + 1;
    else if (L.data[mid] < key)
        return func(L, key, mid + 1, high);
    else
        return func(L, key, low, mid - 1);
} // 递归，时空复杂度分别为 O(logN) 和 O(logN)

//由于每次递归调用消耗的栈空间与递归深度成正比，因此空间复杂度也是 O(logN)
```



## +基础2

**判断给定二叉树是否是二叉(搜索)排序树**

```c
void inprint(BiTree T, int res[], int *index) {
    if (T != NULL) {
        inprint(T->lchild, res, index);
        res[(*index)++] = T->data;
        inprint(T->rchild, res, index);
    }
}

int isSure(int res[], int index) {
    for (int i = 0; i < index - 1; i++)
        if (res[i] >= res[i + 1])
            return 0;
    return 1;
}
// 法一，时空复杂度分别为 O(N) 和 O(N)
```

```c
int func(BiTree T, int low, int high) {
    if (T == NULL)
        return 1;
    if (T->data <= low || T->data >= high)
        return 0;
    int left = func(T->lchild, low, T->data);
    int right = func(T->rchild, T->data, high);
    return left && right;
} // 法二，时空复杂度分别为 O(N) 和 O(N)
```

## +基础3

**寻找二叉排序树中最大值和最小值结点**

```c
BiTree Min(BiTree bt) {
    while (bt->lchild)
        bt = bt->lchild;
    return bt;
}

BiTree Max(BiTree bt) {
    while (bt->rchild)
        bt = bt->rchild;
    return bt;
}
```



## +基础4

**求出值为 key 的结点在二叉排序树的层次**

```c
int level(BiTree bt, int key) {
    int n = 1;
    while (bt != NULL) {
        if (bt->data == key)
            return n;
        else if (bt->data < key) {
            bt = bt->rchild;
            n++;
        } else {
            bt = bt->lchild;
            n++;
        }
    }
    return -1;
}
```



# 查找强化

## +强化1

**创建一个二叉排序树（插入一个树的结点）**

```c
BiTree insert(BiTree BT, int value) {
    if (BT == NULL) {
        BiTree T = (BiTree)malloc(sizeof(BTNode));
        T->data = value;
        T->lchild = NULL;
        T->rchild = NULL;
        return T;
    }
    if (value < BT->data)
        BT->lchild = insert(BT->lchild, value);
    if (value > BT->data)
        BT->rchild = insert(BT->rchild, value);
    return BT;
} // 时空复杂度分别为 O(N) 和 O(N)
```

## 强化2

**查找二叉排序树中第 k 小的结点**

```c
void find(BiTree bt, int k, int *count, BiTree *p) {
    if (bt != NULL) {
        find(bt->lchild, k, count, p);
        (*count)++;
        if ((*count) == k)
            *p = bt;
        find(bt->rchild, k, count, p);
    }
}
```

## 强化3

**输出二叉搜索树中所有值大于 key 的值**

```c
void func(BiTree bt, char key) {
    if (bt != NULL) {
        func(bt->lchild, key);
        if (bt->data > key)
            printf("%d ", bt->data);
        func(bt->rchild, key);
    }
}
```

## +强化4

**判断顺序存储的二叉树是否为二叉搜索树**

```c
typedef struct {
    Elemtype Node[maxsize];
    int ElemNum;
} SqBiTree; // (2022 年统考题)

int func(SqBiTree T, int i, Elemtype low, Elemtype high) {
    if (i >= T.ElemNum || T.Node[i] == -1)
        return 1;
    if (T.Node[i] <= low || T.Node[i] >= high)
        return 0;
    int left = func(T, 2 * i + 1, low, T.Node[i]);
    int right = func(T, 2 * i + 2, T.Node[i], high);
    return left && right;
}
```

## +强化5

**判断一个二叉排序树是否为平衡二叉树**

```c
int height(BiTree T) {
    if (T == NULL) return 0;
    int A = height(T->lchild);
    int B = height(T->rchild);
    return (A > B ? A : B) + 1;
} // 计算高度

int isture(BiTree T) {
    if (T == NULL) return 1;
    int left = height(T->lchild);
    int right = height(T->rchild);
    if (abs(left - right) > 1)
        return 0;
    return isture(T->lchild) && isture(T->rchild);
} // 时空复杂度分别为 O(N) 和 O(N)

int height(SqBiTree T, int i) {
    if (T.Node[i] == -1 || i >= T.ElemNum)
        return 0;
    int A = height(T, 2 * i + 1);
    int B = height(T, 2 * i + 2);
    return (A > B ? A : B) + 1;
}

int isture(SqBiTree T, int i) {
    if (T.Node[i] == -1 || i >= T.ElemNum) return 1;
    int A = height(T, 2 * i + 1);
    int B = height(T, 2 * i + 2);
    if (abs(A - B) > 1) return 0;
    return isture(T, 2 * i + 1) && isture(T, 2 * i + 2);
} // 顺序存储
```

# 排序基础

## 基础1

**直接插入排序**

```c
void func(int A[], int n) {
    int j;
    for (int i = 2; i <= n; i++) {
        A[0] = A[i];
        for (j = i - 1; A[0] < A[j]; j--) {
            A[j + 1] = A[j];
        }
        A[j + 1] = A[0];
    }
} // 时空复杂度分别为 O(N^2) 和 O(1)
```

## +基础2

**折半插入排序**

```c
void func(int A[], int n) {
    int j, low, high, mid;
    for (int i = 2; i <= n; i++) {
        A[0] = A[i];
        low = 1;
        high = i - 1;
        while (low <= high) {
            mid = (low + high) / 2;
            if (A[mid] > A[0])
                high = mid - 1;
            else
                low = mid + 1;
        }
        for (j = i - 1; j >= low; j--) {
            A[j + 1] = A[j];
        }
        A[low] = A[0];
    }
} // 时空复杂度分别为 O(N^2) 和 O(1)
```

## 基础3

**选择排序**

```c
void func(int A[], int n) {
    for (int i = 0; i < n; i++) {
        int pos = i;
        for (int j = i + 1; j < n; j++)
            if (A[pos] > A[j])
                pos = j;
        int temp = A[i];
        A[i] = A[pos];
        A[pos] = temp;
    }
} // 时空复杂度分别为 O(N^2) 和 O(1)
```

## 基础4

**冒泡排序**

```c
void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

void BubbleSort(int A[], int n) {
    for (int i = n - 1; i > 0; i--) {
        int flag = 0;
        for (int j = 1; j <= i; j++) {
            if (A[j - 1] > A[j]) {
                swap(&A[j - 1], &A[j]);
                flag = 1;
            }
        }
        if (flag == 0)
            return;
    }
} // 时空复杂度分别为 O(N^2) 和 O(1)
```

## +基础5

**快速排序**

```c
int foo(int A[], int low, int high) {
    int pivot = A[low];
    while (low < high) {
        while (low < high && A[high] >= pivot)
            high--;
        A[low] = A[high];
        while (low < high && A[low] < pivot)
            low++;
        A[high] = A[low];
    }
    A[low] = pivot;
    return low;
}

void func(int A[], int low, int high) {
    if (low < high) {
        int pos = foo(A, low, high);
        func(A, low, pos - 1);
        func(A, pos + 1, high);
    }
} // 时空复杂度分别为 O(NlogN) 和 O(logN)
```



# 排序强化

## +强化1-

**希尔排序**(背)

```c
void shellsort(int arr[], int n) {
    int temp;
    for (int gap = n / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < n; ++i) {
            temp = arr[i];
            int j = i;
            while (j >= gap && arr[j - gap] > temp) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = temp;
        }
    }
} // 时空复杂度分别为 O(N^2) 和 O(1)
```

## +强化2

**判断数组是否是小根堆**

```c
int isMinHeap(int A[], int n) {
    for (int i = 0; i <= (n - 2) / 2; i++) {
        if (A[i] > A[2 * i + 1])
            return 0;
        if (2 * i + 2 < n && A[i] > A[2 * i + 2])
            return 0;
    }
    return 1;
} // 时空复杂度分别为 O(N) 和 O(1)
```

## +强化3-

**堆排序(从小到大)**

```c
void sift(int A[], int low, int high) {
    int i = low, j = 2 * i + 1;
    int temp = A[i];
    while (j <= high) {
        if (j < high && A[j] < A[j + 1])
            ++j;
        if (temp < A[j]) {
            A[i] = A[j];
            i = j;
            j = 2 * i + 1;
        } else
            break;
    }
    A[i] = temp;
} // 堆调整的时空复杂度分别为 O(logN) 和 O(1)

void heapSort(int A[], int n) {
    for (int i = n / 2 - 1; i >= 0; --i)
        sift(A, i, n - 1);
    for (int i = n - 1; i > 0; --i) {
        int temp = A[0];
        A[0] = A[i];
        A[i] = temp;
        sift(A, 0, i - 1);
    }
} // 堆排序时空复杂度分别为 O(NlogN) 和 O(1)
```

## +强化4

**二路归并排序（背）**

```c
void merge(int A[], int low, int mid, int high) {
    int *B = (int*)malloc((high + 1) * sizeof(int));
    for (int i = low; i <= high; i++)
        B[i] = A[i];

    int i = low, j = mid + 1, k = low;
    while (i <= mid && j <= high)
        if (B[i] <= B[j])
            A[k++] = B[i++];
        else
            A[k++] = B[j++];

    while (i <= mid)
        A[k++] = B[i++];

    while (j <= high)
        A[k++] = B[j++];
}

void mergeSort(int A[], int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2;
        mergeSort(A, low, mid);
        mergeSort(A, mid + 1, high);
        merge(A, low, mid, high);
    }
} // 时空复杂度分别为 O(NlogN) 和 O(N)
```

## +强化5

**带头节点单链表的直接插入排序**

```c
void linksort(LinkList L){
    LinkList p = L->next;
    LinkList r = p->next;
    p->next = NULL;
    p = r;
    while (p != NULL){
        r = p->next;
        LinkList pre = L;
        while (pre->next &&
               pre->next->data < p->data)
            pre = pre->next;
        p->next = pre->next;
        pre->next = p;
        p = r;
    }
} //时空复杂度分别为 O(N^2)和 O(1)
```

## +强化6

**不带头节点单链表的直接插入排序**

```c
void linksort(LinkList* L){
    LinkList p = *L, r = p->next;
    p->next = NULL;
    p = r;
    while (p != NULL){
        r = p->next;
        if(p->data < (*L)->data){ // 先把比头小的头插，即头永远是最小的
            p->next = (*L);
            *L = p;
            p = r;
            continue;
        }
      // 遇到比头大的进行直接插入排序
        LinkList pre = (*L);
        while (pre->next &&
               pre->next->data < p->data)
            pre = pre->next;
        p->next = pre->next;
        pre->next = p;
        p = r;
    }
} //时空复杂度分别为 O(N^2)和 O(1)
```

## +强化7-

**带头节点单链表的简单选择排序**

```c
void selectSort(LinkList L) {
    LinkList p, pre, minPre;
    for (p = L; p->next; p = p->next) {
        minPre = p;
        for (pre = p->next; pre->next; pre = pre->next)
            if (pre->next->data < minPre->next->data)
                minPre = pre;
        LinkList min = minPre->next;
        minPre->next = min->next;
        min->next = p->next;
        p->next = min;
    }
} //时空复杂度分别为 O(N^2)和 O(1)
```

## +强化8

**双向冒泡排序**

```c
void Swap(int *x, int *y){
    int temp = *x;
    *x = *y;
    *y = temp;
}

void BubbleSort(int Arr[], int n){
    int low = 0, high = n - 1, flag = 1;
    while (low < high && flag){
        flag = 0;
        for (int i = high; i > low; i--) //从后向前把小的换到前面
            if (Arr[i - 1] > Arr[i]){
                Swap(&Arr[i - 1], &Arr[i]);
                flag = 1;
            }
        low++;
        for (int j = low + 1; j <= high; j++)//从前向后把大的换到后面
            if (Arr[j - 1] > Arr[j]){
                Swap(&Arr[j - 1], &Arr[j]);
                flag = 1;
            }
        high--;
    }
} //时空复杂度分别为 O(N^2)和 O(1)
```

## 强化9

**已知由 n(n>=2) 个正整数构成的集合 A={ak|0<=ak<n}，将其划分为两个不相交的子集 A1 和 A2，元素个数分别是 n1 和 n2。A1 和 A2 中元素之和分别为 S1 和 S2。设计一个尽可能高效的划分算法，满足 |n1-n2| 最小且 |S1-S2| 最大。（2016 年统考题）**

```c
void func(int A[], int A1[], int A2[], int n){
    Quicksort(A, 0, n-1); // 考试时快排代码要写
    for (int i = 0; i < n/2; ++i)
        A1[i] = A[i];
    for (int i = n/2; i < n; ++i)
        A2[i-n/2] = A[i];
} // 时空复杂度分别为 O(NlogN) 和 O(logN)
```

暴力

```c
#include <stdlib.h>
#include <math.h>

// 功能：将 a[0..n-1] 划分为两个子集，满足：
//      1. 元素个数差最小（|n1 - n2|）
//      2. 在上面条件下，元素和差最大（|s1 - s2|）
// 输入：a -- 输入数组，n -- 元素个数
// 输出：*res_mask -- 最优划分对应的掩码，1 表示在子集1，0 表示在子集2
void split(int *a, int n, int *res_mask) {
    int m = 1 << n;       // 所有划分情况数量（2^n）
    int best = 0;         // 最佳划分的掩码
    int min_cnt = n;      // 当前最小的 |n1 - n2|
    int max_sum = -1;     // 当前最大的 |s1 - s2|

    for (int mk = 0; mk < m; mk++) {
        int c1 = 0, c2 = 0;   // 子集1和2的元素个数
        int s1 = 0, s2 = 0;   // 子集1和2的元素和

        for (int i = 0; i < n; i++) {
            if (mk & (1 << i)) {
                c1++;
                s1 += a[i];
            } else {
                c2++;
                s2 += a[i];
            }
        }

        int d_cnt = abs(c1 - c2);  // 元素个数差
        int d_sum = abs(s1 - s2);  // 元素和差

        // 比较并更新最优结果
        if (d_cnt < min_cnt || (d_cnt == min_cnt && d_sum > max_sum)) {
            min_cnt = d_cnt;
            max_sum = d_sum;
            best = mk;
        }
    }

    *res_mask = best;  // 返回最优划分掩码
}

```

## +强化10-

**找出数组 A 中个第 k 小的元素（快排应用）**

```c
int part(int A[], int low, int high, int k) {
    int pivot = A[low];
    int low_temp = low;
    int high_temp = high;
    while (low < high) {
        while (low < high && A[high] >= pivot)
            --high;
        A[low] = A[high];
        while (low < high && A[low] < pivot)
            ++low;
        A[high] = A[low];
    }
    A[low] = pivot;
    if (low == k - 1)
        return A[low];
    else if (low > k - 1)
        return part(A, low_temp, low - 1, k);
    else
        return part(A, low + 1, high_temp, k);
} // 时空复杂度分别为 O(N) 和 O(logN)
```

## +强化11

**计数排序**

```c
void countSort(int arr[], int n) {
    int max = arr[0], min = arr[0];
    for (int i = 0; i < n; i++) {
        if (arr[i] > max)
            max = arr[i];
        if (arr[i] < min)
            min = arr[i];
    }
    int size = max - min + 1;
    int* B = (int*)malloc(size * sizeof(int));
    for (int i = 0; i < size; i++)
        B[i] = 0;
    for (int i = 0; i < n; i++)
        B[arr[i] - min]++;
    int index = 0;
    for (int i = 0; i < size; i++)
        while (B[i]-- > 0) // 考虑到出现多次的情况
            arr[index++] = i + min;
    free(B);
} //时空复杂度分别为 O(N+K) 和 O(N+K)
```

