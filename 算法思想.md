# 查找

## 折半

折半查找（二分查找）的思想是：在**有序数组**中查找目标值时，每次都拿中间位置的元素与目标值比较：

- 如果中间值等于目标，查找成功；
- 如果中间值大于目标，说明目标在左半边，继续在左半区间查找；
- 如果中间值小于目标，说明目标在右半边，继续在右半区间查找。

通过不断缩小一半的查找范围，快速逼近目标，直到找到或范围为空为止。

**核心前提**：数组必须有序。
**效率**：时间复杂度为 O(log n)，非常高效。

- **优点**：高效，O(log n)，查找快。
- **缺点**：需有序数组，不支持链表，增删维护成本高。

**适用**：静态有序数据。

## 分块

将数据分成若干块，块内可无序，块间必须有序。查找时，先查索引表确定所在块，再在块内顺序查找。

- **优点**：比顺序查找快，支持动态插入，适合大数据分块存储。
- **缺点**：需额外索引空间，查找效率依赖分块大小，维护成本高，不如折半查找高效。

**适用**：数据量大、部分有序或动态变化的场景。

## 二叉排序

特点：

- 若左子树非空，则左子树上的所有节点的值均小于根节点的值
- 若右子树非空，则右子树上的所有节点的值均大于根节点的值
- 左右字数也分别是一颗二叉排序树

**优点**

1. **查找、插入、删除效率较高**：
    在理想情况下（树接近平衡），时间复杂度可达 O(log n)。
2. **中序遍历有序**：
    对 BST 做中序遍历，可以直接得到从小到大的有序序列。
3. **动态更新方便**：
    插入和删除操作无需像顺序表那样整体移动元素。

**缺点**

1. **最坏情况退化为链表**：
    如果插入的数据本身有序，BST 会变成单支链表，查找、插入、删除的时间复杂度退化为 O(n)。
2. **不自平衡**：
    普通 BST 无法自动保持平衡，需要额外机制（如 AVL 树、红黑树）保证性能稳定。
3. **空间开销**：
    需要为每个节点存储指针，会多占用额外内存。
